<<<<<<< HEAD
---
title: 'Lab 13: World Indicators'
author: "Brian Teklits, Charles Doremieux, Andrew MacLean, Clint LaBattaglia"
date: "11/24/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE,message=FALSE)
library(tidyverse)
pump_price <- read_csv("pump_price_for_gasoline_us_per_liter.csv",col_types = cols(`1993` = col_double(),
  `1994` = col_double(),
  `1996` = col_double(),
  `1997` = col_double(),
  `1999` = col_double(),
  `2001` = col_double(),
  `2003` = col_double(),
  `2005` = col_double(),
  `2007` = col_double(),
  `2009` = col_double(),
  `2011` = col_double(),
  `2013` = col_double(),
  `2015` = col_double()))
co2_emissions <- read_csv("co2_emissions_tonnes_per_person.csv")
```

## Team Section

#### Our Research Question 

#### Data Description and Preprocessing

We used two datasets to investigate this question: the first describes the CO2 emissions for 192 countries from as far back as 1800, though the majority of the data comes from more recent years. The second dataset describes the price of the most widely sold type of gasoline in US Dollars. The price comes as a single number for each year: it is not stated to be an average, but given the regular fluctuations of gas prices, we assume it is some sort of average.

We tidied the two datasets, then combined them into a single dataset which contained only years in which both CO2 emission data and gas prices were available.
```{r}
co2_emissions <- co2_emissions %>%
  gather(`1800`:`2014`,key='year',value='CO2 Emissions (Tonnes/person)')

pump_price <- pump_price %>%
  gather(`1991`:`2016`,key = 'year',value = 'Pump Price ($/L)')

co2_and_pump <- co2_emissions %>%
  inner_join(pump_price, by = c('country','year')) %>%
  filter(!is.na(`Pump Price ($/L)`) & !is.na(`CO2 Emissions (Tonnes/person)`))
```

#### Summary Answer


```{r}
t <- co2_and_pump %>% group_by(country) %>% count() %>% filter(n>=10)

(cor_by_country <- co2_and_pump %>%
  semi_join(t) %>%
  group_by(country) %>% 
  nest() %>% 
  mutate(cor = map(data, ~cor(.x$`CO2 Emissions (Tonnes/person)`, .x$`Pump Price ($/L)`))) %>%
  unnest(cor, .drop = TRUE) %>%
   arrange((cor)))
```

```{r}

USA <- co2_and_pump %>% filter(country == "United States")
```

```{r}
perm_test_cor_team <- numeric(1000)

for(i in seq_along(perm_test_cor_team)){
  # Randomize one of variables of interest:
  s <- sample(USA$`CO2 Emissions (Tonnes/person)`)
  # Find the correlation between the un-randomized vector and the randomized vector
  perm_test_cor_team[i] <- cor(USA$`Pump Price ($/L)`,s)
}
USA_cor <- filter(cor_by_country,country == 'United States')$cor
ggplot(tibble(perm_test_cor_team),aes(perm_test_cor_team))+geom_histogram(bins = 30)+
  geom_vline(xintercept = USA_cor, color='red')
```
```{r}
sum(perm_test_cor_team > USA_cor)/length(perm_test_cor_team)
```


## Individual Sections

### Andrew

What is the subquestion you are addressing?

```{r}
#The code for the map function you used and a brief description of what the code is doing

```
A description of the permutation you performed and its results.
Your description should contain the following:
state explicitly the null and alternative hypotheses (i.e., step 1 in “Permutation Test Review”),

what test statistic you are using (i.e., step 2 in “Permutation Test Review”),

a histogram of the distribution of the test statistic (i.e., step 5 in “Permutation Test Review”),

the percentile where the real data summary falls in the distribution (i.e., step 6 in “Permutation Test Review”),

what conclusion you are drawing from the permutation test (i.e., step 7 in “Permutation Test Review”)

A data-based conclusion/answer to your subquestion

### Brian

What is the correlation between gas prices and co2 emissions on a global scale?

For measuring correlations, the pearson correlation coefficient seemed like the natural choice.

Using a map function with the correlation coefficient doesn't work as easily as some other summary statistics. The nest function gives us a list of tibbles, then correlation is calculated using the map function in a mutate for each tibble in the list. Finally, unnest drops all the columns except the calculated correlation and any grouping variables used. The code was referenced from [here](https://community.rstudio.com/t/how-to-use-map-with-cor/6509). 

```{r}
(act_cor <- co2_and_pump %>% 
#  group_by(country) %>% 
  nest() %>% 
  mutate(cor = map(data, ~cor(.x$`CO2 Emissions (Tonnes/person)`, .x$`Pump Price ($/L)`))) %>%
  unnest(cor, .drop = TRUE))
```

For finding a single correlation, using the columns directly in the cor function is much more straight forward. However, this method does yield the same result, and can be expanded to the grouped case, as in the team section.

The null hypothesis is that no correlation exists: the correlation coefficient is 0. The alternate hypothesis is that some correlation exists, so the correlation coefficient is non-zero.

```{r}
perm_test_cor <- numeric(1000)

for(i in seq_along(perm_test_cor)){
  # Randomize one of variables of interest:
  s <- sample(co2_and_pump$`CO2 Emissions (Tonnes/person)`)
  # Find the correlation between the un-randomized vector and the randomized vector
  perm_test_cor[i] <- cor(co2_and_pump$`Pump Price ($/L)`,s)
}

ggplot(tibble(perm_test_cor),aes(perm_test_cor))+geom_histogram(bins = 50)+
  geom_vline(xintercept = act_cor$cor, color='red')
```

The percentile of the actual correlation:
```{r}
sum(act_cor$cor > perm_test_cor)/length(perm_test_cor)
```

Since our result is at the 0th percentile of the permutation tests, we reject the null hypothesis that no correlation exists, in favor of the alternate hypothesis that some correlation exists.

While our calculated correlation appears to be a significant result, the actual value itself is quite small: -.1. This result was fairly surprising to me, as I anticipated a much stronger correlation. This lead to the formulation of the team question, where we found the correlations vary greatly between different countries. Thus, while the worldwide average correlation is very weak, this is because individual countries range across the entire spectrum of positive and negative correlations.

### Charles 

What is the subquestion you are addressing?

```{r}
suicides_100k <- read_csv("suicide_per_100000_people.csv")
sex_ratio <- read_csv("sex_ratio_15_49_years.csv")

suicides_100k <- suicides_100k %>%
  gather(`1950`:`2016`,key='year',value='Suicides (per 100k people)') %>%
  filter(!is.na(`Suicides (per 100k people)`))
sex_ratio <- sex_ratio %>%
  gather(`1950`:`2100`,key='year',value='Male/Female Ratio') %>%
  filter(!is.na(`Male/Female Ratio`))
```

```{r}
```

A description of the permutation you performed and its results.
Your description should contain the following:
state explicitly the null and alternative hypotheses (i.e., step 1 in “Permutation Test Review”),

what test statistic you are using (i.e., step 2 in “Permutation Test Review”),

a histogram of the distribution of the test statistic (i.e., step 5 in “Permutation Test Review”),

the percentile where the real data summary falls in the distribution (i.e., step 6 in “Permutation Test Review”),

what conclusion you are drawing from the permutation test (i.e., step 7 in “Permutation Test Review”)

A data-based conclusion/answer to your subquestion

### Clint

What is the subquestion you are addressing?

```{r}
child_mort <- read_csv("child_mortality_0_5_year_olds_dying_per_1000_born.csv")

birthrate <- read_csv("children_per_woman_total_fertility.csv")

child_mort <- child_mort%>%
  gather('1800':'2018', key = 'year', value = "Child Mortality (# of Deaths per Thousand Births")

birthrate <- birthrate%>%
  gather('1800':'2018', key = 'year', value = "Birthrate (# of Children per woman)")

mort_2018 <- child_mort%>%
  filter(year == "2018", !is.na(`Child Mortality (# of Deaths per Thousand Births`))%>%
  arrange(desc(`Child Mortality (# of Deaths per Thousand Births`))

birth_2018 <- birthrate%>%
  filter(year == "2018",!is.na(`Birthrate (# of Children per woman)`))%>%
  arrange(desc(`Birthrate (# of Children per woman)`))
```

```{r}
top_mort <- mort_2018%>%
  filter(`Child Mortality (# of Deaths per Thousand Births` >= 42.90)

bottom_mort <- mort_2018%>%
  filter(mort_2018$`Child Mortality (# of Deaths per Thousand Births` <= 7.97)

top_birth <- birth_2018%>%
  filter(`Birthrate (# of Children per woman)` >= 3.56)

bottom_birth <-birth_2018%>%
  filter(`Birthrate (# of Children per woman)` <= 1.76)

high_and_low_mort <- top_mort %>% full_join(bottom_mort)

high_and_low_birth <- top_birth %>% full_join(bottom_birth)

combined_data <- high_and_low_birth%>% inner_join(high_and_low_mort, by = c('country','year'))
```


```{r}
real_cor <- cor(x = combined_data$`Birthrate (# of Children per woman)`,y = combined_data$`Child Mortality (# of Deaths per Thousand Births`) # 0.927

perm_test_clint <- numeric(1000)

for(i in seq_along(perm_test_clint)){
  sam <- sample(combined_data$`Birthrate (# of Children per woman)`)
  perm_test_clint[i] <- cor(combined_data$`Child Mortality (# of Deaths per Thousand Births`,sam)
}

percentiles_cor_test <- ecdf(perm_test_clint)
percentiles_cor_test(real_cor) #1
range(perm_test_clint) #-0.337, 0.356 

ggplot(tibble(perm_test_clint),aes(perm_test_clint))+geom_histogram(bins = 50)+
  geom_vline(xintercept = real_cor, color='yellow')
```
A description of the permutation you performed and its results.
Your description should contain the following:
state explicitly the null and alternative hypotheses (i.e., step 1 in “Permutation Test Review”),

what test statistic you are using (i.e., step 2 in “Permutation Test Review”),

a histogram of the distribution of the test statistic (i.e., step 5 in “Permutation Test Review”),

the percentile where the real data summary falls in the distribution (i.e., step 6 in “Permutation Test Review”),

what conclusion you are drawing from the permutation test (i.e., step 7 in “Permutation Test Review”)

A data-based conclusion/answer to your subquestion
